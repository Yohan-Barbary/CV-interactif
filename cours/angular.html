<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angular - Formation DWWM</title>
    <link rel="stylesheet" href="../commun/styles.css">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="l-header">
        <nav class="navbar">
            <div class="nav-content">
                <div class="logo">
                    <a href="../index.html" class="logo-text">&lt;DWWM/&gt;</a>
                </div>
                <ul class="nav-links">
                    <li><a href="../index.html"><i class="fas fa-home"></i><span class="nav-text">Accueil</span></a></li>
                    <li><a href="../lexique/lexique.html"><i class="fas fa-book"></i><span class="nav-text">Lexique</span></a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main class="course-content">
        <h1><i class="fab fa-angular"></i> Angular</h1>
        
        <section class="course-section hero-section">
            <div class="hero-content">
                <div class="hero-text">
                    <h2>Qu'est-ce qu'Angular ?</h2>
                    <p class="hero-description">
                        Angular est un framework front-end développé et maintenu par Google, conçu pour créer des applications web dynamiques et performantes. C'est une réécriture complète de AngularJS, offrant de meilleures performances et une architecture plus moderne.
                    </p>
                    <div class="hero-features">
                        <div class="hero-feature">
                            <i class="fas fa-rocket"></i>
                            <span>Framework Complet</span>
                        </div>
                        <div class="hero-feature">
                            <i class="fas fa-code"></i>
                            <span>TypeScript Native</span>
                        </div>
                        <div class="hero-feature">
                            <i class="fas fa-puzzle-piece"></i>
                            <span>Modulaire</span>
                        </div>
                    </div>
                </div>
                <div class="hero-image">
                    <img src="https://angular.io/assets/images/logos/angular/angular.svg" alt="Logo Angular">
                </div>
            </div>
        </section>

        <section class="course-section comparison-section">
            <h2>Angular vs JavaScript : Comprendre les Différences</h2>
            
            <div class="comparison-grid">
                <!-- Gestion des événements -->
                <article class="comparison-item">
                    <h3>Gestion des Événements</h3>
                    <div class="code-comparison">
                        <div class="code-block js-block">
                            <h4>JavaScript Vanilla</h4>
                            <div class="code-example">
                                <code>
// JavaScript
document.getElementById('button').addEventListener('click', function() {
    const input = document.getElementById('input');
    const display = document.getElementById('display');
    display.textContent = input.value;
});
                                </code>
                            </div>
                        </div>
                        <div class="code-block angular-block">
                            <h4>Angular</h4>
                            <div class="code-example">
                                <code>
<!-- Template Angular -->
&lt;button (click)="updateDisplay()"&gt;Cliquer&lt;/button&gt;
&lt;input [(ngModel)]="inputValue"&gt;
&lt;p&gt;{{ inputValue }}&lt;/p&gt;

// Component
export class MyComponent {
    inputValue: string = '';
    updateDisplay() {
        // La mise à jour est automatique grâce au binding
    }
}
                                </code>
                            </div>
                        </div>
                    </div>
                </article>

                <!-- Manipulation du DOM -->
                <article class="comparison-item">
                    <h3>Manipulation du DOM</h3>
                    <div class="code-comparison">
                        <div class="code-block js-block">
                            <h4>JavaScript Vanilla</h4>
                            <div class="code-example">
                                <code>
// JavaScript
const items = ['Item 1', 'Item 2', 'Item 3'];
const ul = document.createElement('ul');

items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    ul.appendChild(li);
});

document.getElementById('list-container').appendChild(ul);
                                </code>
                            </div>
                        </div>
                        <div class="code-block angular-block">
                            <h4>Angular</h4>
                            <div class="code-example">
                                <code>
<!-- Template Angular -->
&lt;ul&gt;
    &lt;li *ngFor="let item of items"&gt;{{ item }}&lt;/li&gt;
&lt;/ul&gt;

// Component
export class MyComponent {
    items = ['Item 1', 'Item 2', 'Item 3'];
}
                                </code>
                            </div>
                        </div>
                    </div>
                </article>

                <!-- Gestion de l'état -->
                <article class="comparison-item">
                    <h3>Gestion de l'État</h3>
                    <div class="code-comparison">
                        <div class="code-block js-block">
                            <h4>JavaScript Vanilla</h4>
                            <div class="code-example">
                                <code>
// JavaScript
let state = {
    count: 0,
    todos: []
};

function updateState(newState) {
    state = { ...state, ...newState };
    renderUI(); // Fonction manuelle pour mettre à jour l'UI
}

function renderUI() {
    document.getElementById('count').textContent = state.count;
    const todoList = document.getElementById('todos');
    todoList.innerHTML = '';
    state.todos.forEach(todo => {
        const li = document.createElement('li');
        li.textContent = todo;
        todoList.appendChild(li);
    });
}
                                </code>
                            </div>
                        </div>
                        <div class="code-block angular-block">
                            <h4>Angular</h4>
                            <div class="code-example">
                                <code>
// Service
@Injectable({
    providedIn: 'root'
})
export class StateService {
    private state = new BehaviorSubject({
        count: 0,
        todos: []
    });

    updateState(newState: Partial<State>) {
        this.state.next({
            ...this.state.value,
            ...newState
        });
    }
}

// Component
@Component({
    template: `
        &lt;div&gt;Count: {{ state.count }}&lt;/div&gt;
        &lt;ul&gt;
            &lt;li *ngFor="let todo of state.todos"&gt;
                {{ todo }}
            &lt;/li&gt;
        &lt;/ul&gt;
    `
})
export class AppComponent {
    state$ = this.stateService.state$;
}
                                </code>
                            </div>
                        </div>
                    </div>
                </article>

                <!-- Requêtes HTTP -->
                <article class="comparison-item">
                    <h3>Requêtes HTTP</h3>
                    <div class="code-comparison">
                        <div class="code-block js-block">
                            <h4>JavaScript Vanilla</h4>
                            <div class="code-example">
                                <code>
// JavaScript
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => {
        const container = document.getElementById('data');
        container.innerHTML = '';
        data.forEach(item => {
            const div = document.createElement('div');
            div.textContent = item.name;
            container.appendChild(div);
        });
    })
    .catch(error => {
        console.error('Erreur:', error);
        document.getElementById('error').textContent = 
            'Une erreur est survenue';
    });
                                </code>
                            </div>
                        </div>
                        <div class="code-block angular-block">
                            <h4>Angular</h4>
                            <div class="code-example">
                                <code>
// Service
@Injectable()
export class DataService {
    constructor(private http: HttpClient) {}

    getData() {
        return this.http.get('https://api.example.com/data');
    }
}

// Component
@Component({
    template: `
        &lt;div *ngIf="data$ | async as data"&gt;
            &lt;div *ngFor="let item of data"&gt;
                {{ item.name }}
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div *ngIf="error"&gt;{{ error }}&lt;/div&gt;
    `
})
export class AppComponent {
    data$ = this.dataService.getData().pipe(
        catchError(error => {
            this.error = 'Une erreur est survenue';
            return EMPTY;
        })
    );
}
                                </code>
                            </div>
                        </div>
                    </div>
                </article>
            </div>

            <div class="key-differences">
                <h3>Avantages Clés d'Angular</h3>
                <ul>
                    <li>
                        <strong>Binding Bidirectionnel :</strong> 
                        Synchronisation automatique entre le modèle et la vue
                    </li>
                    <li>
                        <strong>Gestion d'État Structurée :</strong> 
                        Services et RxJS pour une gestion d'état plus prévisible
                    </li>
                    <li>
                        <strong>Templating Déclaratif :</strong> 
                        Syntaxe plus claire et maintenable
                    </li>
                    <li>
                        <strong>Injection de Dépendances :</strong> 
                        Architecture modulaire et testable
                    </li>
                    <li>
                        <strong>TypeScript :</strong> 
                        Typage statique et meilleure détection des erreurs
                    </li>
                </ul>
            </div>
        </section>

        <section class="course-section syntax-section">
            <h2>Syntaxe et Structure</h2>
            
            <div class="syntax-comparison">
                <article class="syntax-item">
                    <h3>Structure d'un Composant Angular</h3>
                    <div class="code-example">
                        <code>
// mon-composant.component.ts
@Component({
    selector: 'app-mon-composant',
    template: `
        &lt;div class="container"&gt;
            &lt;h1&gt;{{ titre }}&lt;/h1&gt;
            &lt;button (click)="onClick()"&gt;Cliquez-moi&lt;/button&gt;
        &lt;/div&gt;
    `
})
export class MonComposantComponent {
    titre = 'Mon Titre';
    onClick() {
        console.log('Bouton cliqué!');
    }
}
                        </code>
                    </div>
                </article>

                <article class="syntax-item">
                    <h3>Différences avec JavaScript Vanilla</h3>
                    <div class="comparison-table">
                        <div class="comparison-row">
                            <div class="feature">
                                <h4>En JavaScript</h4>
                                <div class="code-example">
                                    <code>
// JavaScript classique
document.getElementById('monBouton')
    .addEventListener('click', function() {
    console.log('Cliqué!');
});

// Mise à jour du DOM
document.querySelector('h1')
    .textContent = 'Nouveau titre';
                                    </code>
                                </div>
                            </div>
                            <div class="feature">
                                <h4>En Angular</h4>
                                <div class="code-example">
                                    <code>
// Template Angular
&lt;button (click)="onClick()"&gt;
    Cliquez-moi
&lt;/button&gt;

&lt;h1&gt;{{ titre }}&lt;/h1&gt;
                                    </code>
                                </div>
                            </div>
                        </div>
                    </div>
                </article>

                <article class="syntax-item">
                    <h3>Principales Directives Angular</h3>
                    <div class="directives-list">
                        <div class="directive">
                            <h4>*ngIf</h4>
                            <p>Affichage conditionnel</p>
                            <div class="code-example">
                                <code>&lt;div *ngIf="condition"&gt;Visible si condition vraie&lt;/div&gt;</code>
                            </div>
                        </div>
                        <div class="directive">
                            <h4>*ngFor</h4>
                            <p>Boucle sur une collection</p>
                            <div class="code-example">
                                <code>&lt;li *ngFor="let item of items"&gt;{{ item }}&lt;/li&gt;</code>
                            </div>
                        </div>
                        <div class="directive">
                            <h4>[(ngModel)]</h4>
                            <p>Liaison bidirectionnelle</p>
                            <div class="code-example">
                                <code>&lt;input [(ngModel)]="userName"&gt;</code>
                            </div>
                        </div>
                    </div>
                </article>
            </div>
        </section>

        <section class="course-section features-section">
            <h2>Fonctionnalités Principales</h2>
            
            <div class="intro-text">
                <p>Les fonctionnalités principales d'Angular constituent le cœur du framework. Comprendre ces concepts est essentiel pour développer des applications robustes et maintenables. Voyons en détail chaque fonctionnalité et son utilisation pratique.</p>
            </div>

            <article class="feature-block">
                <h3>Data Binding</h3>
                <div class="feature-explanation">
                    <p>Le Data Binding est l'un des concepts les plus puissants d'Angular. Il permet de synchroniser automatiquement les données entre le modèle (la logique) et la vue (l'interface utilisateur). Cette synchronisation peut se faire dans différentes directions :</p>
                    <ul class="feature-benefits">
                        <li>Réduction du code boilerplate</li>
                        <li>Mise à jour automatique de l'interface</li>
                        <li>Meilleure maintenabilité du code</li>
                    </ul>
                </div>
                
                <div class="feature-types">
                    <div class="binding-type">
                        <h4>Interpolation</h4>
                        <p>Utilisée pour afficher des valeurs dynamiques dans le template. Idéale pour l'affichage simple de données.</p>
                        <div class="code-example">
                            <code>{{ '{{variable}}' }}</code>
                        </div>
                    </div>

                    <div class="binding-type">
                        <h4>Property Binding</h4>
                        <p>Permet de lier des propriétés d'éléments HTML à des valeurs du composant. Parfait pour les attributs dynamiques.</p>
                        <div class="code-example">
                            <code>[property]="value"</code>
                        </div>
                    </div>

                    <div class="binding-type">
                        <h4>Event Binding</h4>
                        <p>Capture les événements de l'interface utilisateur. Utilisé pour réagir aux actions de l'utilisateur.</p>
                        <div class="code-example">
                            <code>(event)="handler()"</code>
                        </div>
                    </div>

                    <div class="binding-type">
                        <h4>Two-way Binding</h4>
                        <p>Combine property et event binding. Idéal pour les formulaires et les entrées utilisateur.</p>
                        <div class="code-example">
                            <code>[(ngModel)]="property"</code>
                        </div>
                    </div>
                </div>

                <div class="practical-example">
                    <h4>Exemple Pratique</h4>
                    <p>Voici un exemple concret de formulaire utilisant différents types de binding :</p>
                    <div class="code-example">
                        <code>
&lt;form&gt;
    &lt;input [(ngModel)]="userName" name="userName"&gt;
    &lt;p&gt;Bonjour {{userName}}!&lt;/p&gt;
    &lt;button [disabled]="!userName" (click)="submit()"&gt;
        Envoyer
    &lt;/button&gt;
&lt;/form&gt;
                        </code>
                    </div>
                </div>
            </article>

            <article class="feature-block">
                <h3>Directives</h3>
                <div class="feature-explanation">
                    <p>Les directives sont des marqueurs sur les éléments DOM qui indiquent à Angular comment modifier ou transformer ces éléments. Elles sont essentielles pour créer une interface utilisateur dynamique et réactive.</p>
                </div>

                <div class="directives-types">
                    <div class="directive-category">
                        <h4>Directives Structurelles</h4>
                        <p>Ces directives modifient la structure du DOM. Elles sont reconnaissables par leur astérisque (*) et sont utilisées pour :</p>
                        <ul>
                            <li>
                                <strong>*ngIf</strong>
                                <p>Afficher ou masquer des éléments conditionnellement. Utile pour le rendu conditionnel.</p>
                                <div class="code-example">
                                    <code>&lt;div *ngIf="condition"&gt;Contenu conditionnel&lt;/div&gt;</code>
                                </div>
                            </li>
                            <li>
                                <strong>*ngFor</strong>
                                <p>Répéter des éléments pour chaque élément d'une collection. Parfait pour les listes et tableaux.</p>
                                <div class="code-example">
                                    <code>&lt;li *ngFor="let item of items"&gt;{{item}}&lt;/li&gt;</code>
                                </div>
                            </li>
                            <li>
                                <strong>*ngSwitch</strong>
                                <p>Afficher différents contenus selon une condition. Alternative à plusieurs *ngIf.</p>
                                <div class="code-example">
                                    <code>
&lt;div [ngSwitch]="value"&gt;
    &lt;p *ngSwitchCase="'A'"&gt;Cas A&lt;/p&gt;
    &lt;p *ngSwitchCase="'B'"&gt;Cas B&lt;/p&gt;
    &lt;p *ngSwitchDefault&gt;Cas par défaut&lt;/p&gt;
&lt;/div&gt;
                                    </code>
                                </div>
                            </li>
                        </ul>
                    </div>

                    <div class="directive-category">
                        <h4>Directives d'Attributs</h4>
                        <p>Ces directives modifient l'apparence ou le comportement d'un élément. Utilisées pour :</p>
                        <ul>
                            <li>
                                <strong>ngClass</strong>
                                <p>Ajouter ou supprimer des classes CSS dynamiquement.</p>
                                <div class="code-example">
                                    <code>[ngClass]="{'active': isActive, 'disabled': isDisabled}"</code>
                                </div>
                            </li>
                            <li>
                                <strong>ngStyle</strong>
                                <p>Appliquer des styles CSS dynamiquement.</p>
                                <div class="code-example">
                                    <code>[ngStyle]="{'color': textColor, 'font-size': fontSize + 'px'}"</code>
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>
            </article>
        </section>

        <section class="course-section advanced-components">
            <h2>Composants Avancés</h2>
            
            <div class="intro-text">
                <p>Les composants avancés dans Angular permettent de créer des applications plus sophistiquées et maintenables. Comprendre ces concepts est essentiel pour développer des applications professionnelles.</p>
            </div>

            <article class="feature-block">
                <h3>Cycle de Vie des Composants</h3>
                <div class="feature-explanation">
                    <p>Le cycle de vie d'un composant Angular suit une séquence d'événements prévisible, de sa création à sa destruction. Chaque hook du cycle de vie a un objectif spécifique :</p>
                    
                    <div class="lifecycle-hooks">
                        <div class="hook-item">
                            <h4>ngOnInit</h4>
                            <p>Appelé après la création du composant et l'initialisation des propriétés liées.</p>
                            <p><strong>Utilisation :</strong> Idéal pour :</p>
                            <ul>
                                <li>Initialiser les données</li>
                                <li>Charger des données depuis un service</li>
                                <li>Configurer des souscriptions</li>
                            </ul>
                        </div>

                        <div class="hook-item">
                            <h4>ngOnChanges</h4>
                            <p>Déclenché lorsqu'une propriété liée (@Input) est modifiée.</p>
                            <p><strong>Utilisation :</strong> Parfait pour :</p>
                            <ul>
                                <li>Réagir aux changements de données externes</li>
                                <li>Mettre à jour des calculs dépendants</li>
                                <li>Valider les nouvelles valeurs</li>
                            </ul>
                        </div>

                        <div class="hook-item">
                            <h4>ngDoCheck</h4>
                            <p>Exécuté pendant chaque détection de changement.</p>
                            <p><strong>Utilisation :</strong> Utilisé pour :</p>
                            <ul>
                                <li>Vérifications personnalisées</li>
                                <li>Détection de changements complexes</li>
                                <li>Optimisations de performance</li>
                            </ul>
                        </div>

                        <div class="hook-item">
                            <h4>ngOnDestroy</h4>
                            <p>Appelé juste avant que le composant ne soit détruit.</p>
                            <p><strong>Utilisation :</strong> Essentiel pour :</p>
                            <ul>
                                <li>Nettoyer les souscriptions</li>
                                <li>Libérer les ressources</li>
                                <li>Éviter les fuites de mémoire</li>
                            </ul>
                        </div>
                    </div>

                    <div class="practical-example">
                        <h4>Exemple Pratique</h4>
                        <div class="code-example">
                            <code>
@Component({
    selector: 'app-data-component',
    template: `
        &lt;div *ngIf="data"&gt;
            {{ data.title }}
        &lt;/div&gt;
    `
})
export class DataComponent implements OnInit, OnDestroy {
    @Input() id: string;
    private subscription: Subscription;
    data: any;

    constructor(private dataService: DataService) {}

    ngOnInit() {
        // Initialisation et chargement des données
        this.subscription = this.dataService.getData(this.id)
            .subscribe(
                data => this.data = data,
                error => console.error('Erreur:', error)
            );
    }

    ngOnChanges(changes: SimpleChanges) {
        // Réagir aux changements de l'input id
        if (changes.id) {
            console.log('ID changé:', changes.id.currentValue);
            // Recharger les données si nécessaire
        }
    }

    ngOnDestroy() {
        // Nettoyage
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
                            </code>
                        </div>
                    </div>
                </div>
            </article>
        </section>

        <section class="course-section routing-section">
            <h2>Routing dans Angular</h2>
            
            <div class="intro-text">
                <p>Le routing est un élément fondamental d'Angular qui permet de créer des applications à page unique (SPA) avec une navigation fluide entre différentes vues. Il offre une gestion avancée des routes avec des fonctionnalités comme la navigation imbriquée, les guards, et les resolvers.</p>
            </div>

            <article class="feature-block">
                <h3>Configuration de Base</h3>
                <div class="feature-explanation">
                    <p>La configuration des routes définit la structure de navigation de votre application :</p>
                    <div class="code-example">
                        <code>
// app-routing.module.ts
const routes: Routes = [
    { path: '', component: HomeComponent },
    { path: 'products', component: ProductsComponent },
    { path: 'product/:id', component: ProductDetailComponent }
];

@NgModule({
    imports: [RouterModule.forRoot(routes)],
    exports: [RouterModule]
})
export class AppRoutingModule { }
                        </code>
                    </div>
                </div>

                <div class="routing-features">
                    <div class="feature-item">
                        <h4>Routes Paramétrées</h4>
                        <p>Permettent de passer des données via l'URL :</p>
                        <div class="code-example">
                            <code>
// Dans le composant
constructor(private route: ActivatedRoute) {
    this.route.params.subscribe(params => {
        const id = params['id'];
        // Charger les données avec l'ID
    });
}
                            </code>
                        </div>
                    </div>

                    <div class="feature-item">
                        <h4>Navigation Programmatique</h4>
                        <p>Navigation depuis le code TypeScript :</p>
                        <div class="code-example">
                            <code>
constructor(private router: Router) {}

navigateToProduct(id: string) {
    this.router.navigate(['/product', id]);
}
                            </code>
                        </div>
                    </div>

                    <div class="feature-item">
                        <h4>Guards de Route</h4>
                        <p>Protection et contrôle d'accès aux routes :</p>
                        <div class="code-example">
                            <code>
@Injectable()
export class AuthGuard {
    canActivate(): boolean {
        return this.authService.isAuthenticated();
    }
}

// Dans la configuration des routes
{
    path: 'admin',
    component: AdminComponent,
    canActivate: [AuthGuard]
}
                            </code>
                        </div>
                    </div>
                </div>
            </article>

            <article class="feature-block">
                <h3>Bonnes Pratiques de Routing</h3>
                <div class="best-practices-list">
                    <div class="practice-item">
                        <h4>Structure Modulaire</h4>
                        <ul>
                            <li>Séparer les routes par module fonctionnel</li>
                            <li>Utiliser le lazy loading pour les modules</li>
                            <li>Implémenter une stratégie de préchargement adaptée</li>
                        </ul>
                    </div>

                    <div class="practice-item">
                        <h4>Navigation</h4>
                        <ul>
                            <li>Utiliser des routes nommées pour la maintenance</li>
                            <li>Gérer correctement les redirections</li>
                            <li>Implémenter une page 404</li>
                        </ul>
                    </div>

                    <div class="practice-item">
                        <h4>Sécurité</h4>
                        <ul>
                            <li>Protéger les routes sensibles avec des guards</li>
                            <li>Valider les paramètres de route</li>
                            <li>Gérer les permissions utilisateur</li>
                        </ul>
                    </div>
                </div>
            </article>
        </section>

        <section class="course-section state-management-section">
            <h2>Gestion d'État Avancée</h2>
            
            <div class="intro-text">
                <p>La gestion d'état est un aspect crucial des applications Angular modernes. Elle permet de gérer efficacement les données à travers l'application, de maintenir la cohérence et d'améliorer les performances. Découvrons les différentes approches et outils disponibles.</p>
            </div>

            <article class="feature-block">
                <h3>NgRx Store</h3>
                <div class="feature-explanation">
                    <p>NgRx est une implémentation des principes Redux pour Angular. Il fournit une gestion d'état prévisible pour les applications de grande envergure.</p>
                    
                    <div class="ngrx-concepts">
                        <div class="concept-item">
                            <h4>Store</h4>
                            <p>Conteneur unique de l'état de l'application</p>
                            <div class="code-example">
                                <code>
// Définition de l'état
interface AppState {
    todos: Todo[];
    loading: boolean;
}

// Accès au store
@Component({...})
export class TodoComponent {
    todos$ = this.store.select(state => state.todos);
    constructor(private store: Store<AppState>) {}
}
                                </code>
                            </div>
                        </div>

                        <div class="concept-item">
                            <h4>Actions</h4>
                            <p>Décrivent les événements qui modifient l'état</p>
                            <div class="code-example">
                                <code>
export const loadTodos = createAction('[Todo] Load Todos');
export const addTodo = createAction(
    '[Todo] Add Todo',
    props<{ todo: Todo }>()
);
                                </code>
                            </div>
                        </div>

                        <div class="concept-item">
                            <h4>Reducers</h4>
                            <p>Fonctions pures qui spécifient comment l'état change</p>
                            <div class="code-example">
                                <code>
export const todoReducer = createReducer(
    initialState,
    on(loadTodos, state => ({ ...state, loading: true })),
    on(addTodo, (state, { todo }) => ({
        ...state,
        todos: [...state.todos, todo]
    }))
);
                                </code>
                            </div>
                        </div>

                        <div class="concept-item">
                            <h4>Effects</h4>
                            <p>Gèrent les opérations asynchrones et les effets de bord</p>
                            <div class="code-example">
                                <code>
@Injectable()
export class TodoEffects {
    loadTodos$ = createEffect(() =>
        this.actions$.pipe(
            ofType(loadTodos),
            mergeMap(() => this.todoService.getTodos()
                .pipe(
                    map(todos => loadTodosSuccess({ todos })),
                    catchError(error => of(loadTodosError({ error })))
                ))
        )
    );
}
                                </code>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <article class="feature-block">
                <h3>Signals (Nouveau dans Angular 16+)</h3>
                <div class="feature-explanation">
                    <p>Les Signals représentent une nouvelle approche de la réactivité dans Angular, offrant une alternative plus légère et performante aux Observables pour certains cas d'usage.</p>
                    
                    <div class="signals-examples">
                        <div class="example-item">
                            <h4>Création et Utilisation Basique</h4>
                            <div class="code-example">
                                <code>
export class CounterComponent {
    // Création d'un signal
    count = signal(0);
    
    // Signal calculé (computed)
    doubled = computed(() => this.count() * 2);
    
    increment() {
        // Mise à jour du signal
        this.count.update(n => n + 1);
    }
}
                                </code>
                            </div>
                        </div>

                        <div class="example-item">
                            <h4>Utilisation dans le Template</h4>
                            <div class="code-example">
                                <code>
@Component({
    template: `
        &lt;div&gt;Count: {{ count() }}&lt;/div&gt;
        &lt;div&gt;Doubled: {{ doubled() }}&lt;/div&gt;
        &lt;button (click)="increment()"&gt;Increment&lt;/button&gt;
    `
})
                        </code>
                    </div>
                </div>

                <div class="example-item">
                    <h4>Avantages des Signals</h4>
                    <ul class="benefits-list">
                        <li>Performance améliorée</li>
                        <li>Syntaxe plus simple</li>
                        <li>Meilleure intégration avec le système de change detection</li>
                        <li>Débogage facilité</li>
                    </ul>
                </div>
            </div>
        </div>
    </article>
</section>

        <section class="course-section performance-section">
            <h2>Performance et Optimisation</h2>
            
            <div class="intro-text">
                <p>L'optimisation des performances est cruciale pour offrir une expérience utilisateur fluide. Angular propose plusieurs stratégies et techniques pour améliorer les performances de vos applications.</p>
            </div>

            <article class="feature-block">
                <h3>Change Detection</h3>
                <div class="feature-explanation">
                    <p>La détection des changements est le mécanisme par lequel Angular met à jour le DOM en fonction des modifications de l'état de l'application. L'optimisation de ce processus est essentielle pour de meilleures performances.</p>
                    
                    <div class="detection-strategies">
                        <div class="strategy-item">
                            <h4>Stratégie OnPush</h4>
                            <p>Réduit le nombre de vérifications de changements en ne les déclenchant que lors de modifications d'entrées ou d'événements.</p>
                            <div class="code-example">
                                <code>
@Component({
    selector: 'app-optimized',
    template: `
        &lt;div&gt;{{ data }}&lt;/div&gt;
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class OptimizedComponent {
    @Input() data: any;
}
                                </code>
                            </div>
                        </div>

                        <div class="strategy-item">
                            <h4>Détection Manuelle</h4>
                            <p>Contrôle total sur le moment où la détection des changements doit être exécutée.</p>
                            <div class="code-example">
                                <code>
export class ManualComponent {
    constructor(private cd: ChangeDetectorRef) {}

    updateView() {
        // Mettre à jour les données
        this.cd.detectChanges();
    }

    detachView() {
        this.cd.detach(); // Désactive la détection automatique
    }
}
                                </code>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <article class="feature-block">
                <h3>Lazy Loading</h3>
                <div class="feature-explanation">
                    <p>Le chargement paresseux permet de réduire la taille du bundle initial en ne chargeant les modules qu'au moment où ils sont nécessaires.</p>
                    
                    <div class="lazy-loading-examples">
                        <div class="example-item">
                            <h4>Configuration des Routes</h4>
                            <div class="code-example">
                                <code>
const routes: Routes = [
    {
        path: 'admin',
        loadChildren: () => 
            import('./admin/admin.module').then(m => m.AdminModule)
    }
];
                                </code>
                            </div>
                        </div>

                        <div class="example-item">
                            <h4>Preloading Strategy</h4>
                            <p>Stratégie de préchargement pour améliorer l'expérience utilisateur</p>
                            <div class="code-example">
                                <code>
@NgModule({
    imports: [
        RouterModule.forRoot(routes, {
            preloadingStrategy: PreloadAllModules
        })
    ]
})
                                </code>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <article class="feature-block">
                <h3>Optimisations Avancées</h3>
                <div class="optimization-techniques">
                    <div class="technique-item">
                        <h4>Virtual Scrolling</h4>
                        <p>Optimise le rendu des longues listes en ne rendant que les éléments visibles.</p>
                        <div class="code-example">
                            <code>
&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;
    &lt;div *cdkVirtualFor="let item of items"&gt;
        {{ item }}
    &lt;/div&gt;
&lt;/cdk-virtual-scroll-viewport&gt;
                            </code>
                        </div>
                    </div>

                    <div class="technique-item">
                        <h4>Pure Pipes</h4>
                        <p>Optimise les transformations de données en mettant en cache les résultats.</p>
                        <div class="code-example">
                            <code>
@Pipe({
    name: 'filter',
    pure: true
})
export class FilterPipe implements PipeTransform {
    transform(items: any[], filter: string): any[] {
        return items.filter(item => 
            item.name.includes(filter)
        );
    }
}
                            </code>
                        </div>
                    </div>

                    <div class="technique-item">
                        <h4>Meilleures Pratiques</h4>
                        <ul class="best-practices">
                            <li>Utiliser trackBy avec *ngFor pour optimiser les listes</li>
                            <li>Implémenter OnPush pour les composants statiques</li>
                            <li>Éviter les calculs complexes dans les templates</li>
                            <li>Optimiser les souscriptions RxJS</li>
                            <li>Utiliser le Server-Side Rendering quand approprié</li>
                        </ul>
                    </div>
                </div>
            </article>
        </section>

        <section class="course-section testing-section">
            <h2>Tests et Débogage</h2>
            
            <div class="intro-text">
                <p>Les tests sont une partie essentielle du développement d'applications Angular. Un bon ensemble de tests permet d'assurer la qualité du code et facilite la maintenance. Angular fournit des outils puissants pour différents types de tests.</p>
            </div>

            <article class="feature-block">
                <h3>Tests Unitaires avec Jasmine</h3>
                <div class="feature-explanation">
                    <p>Les tests unitaires permettent de vérifier le comportement individuel des composants, services et autres éléments de votre application.</p>
                    
                    <div class="testing-examples">
                        <div class="example-item">
                            <h4>Configuration de Base</h4>
                            <div class="code-example">
                                <code>
describe('MonComposant', () => {
    let component: MonComposant;
    let fixture: ComponentFixture<MonComposant>;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            declarations: [ MonComposant ],
            imports: [ HttpClientModule ],
            providers: [ MonService ]
        }).compileComponents();

        fixture = TestBed.createComponent(MonComposant);
        component = fixture.componentInstance;
        fixture.detectChanges();
    });

    it('devrait créer le composant', () => {
        expect(component).toBeTruthy();
    });
});
                        </code>
                            </div>
                        </div>

                        <div class="example-item">
                            <h4>Test des Services</h4>
                            <div class="code-example">
                                <code>
describe('DataService', () => {
    let service: DataService;
    let httpMock: HttpTestingController;

    beforeEach(() => {
        TestBed.configureTestingModule({
            imports: [ HttpClientTestingModule ],
            providers: [ DataService ]
        });

        service = TestBed.inject(DataService);
        httpMock = TestBed.inject(HttpTestingController);
    });

    it('devrait récupérer les données', () => {
        const testData = { id: 1, name: 'Test' };

        service.getData().subscribe(data => {
            expect(data).toEqual(testData);
        });

        const req = httpMock.expectOne('/api/data');
        expect(req.request.method).toBe('GET');
        req.flush(testData);
    });
});
                        </code>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <article class="feature-block">
                <h3>Tests d'Intégration</h3>
                <div class="feature-explanation">
                    <p>Les tests d'intégration vérifient l'interaction entre différents composants et services de votre application.</p>
                    
                    <div class="integration-examples">
                        <div class="example-item">
                            <h4>Test des Interactions</h4>
                            <div class="code-example">
                                <code>
describe('UserComponent Integration', () => {
    let component: UserComponent;
    let userService: UserService;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            declarations: [ UserComponent, UserListComponent ],
            providers: [ UserService ]
        }).compileComponents();

        component = TestBed.createComponent(UserComponent).componentInstance;
        userService = TestBed.inject(UserService);
    });

    it('devrait charger et afficher les utilisateurs', fakeAsync(() => {
        const users = [{ id: 1, name: 'Test User' }];
        spyOn(userService, 'getUsers').and.returnValue(of(users));

        component.ngOnInit();
        tick();

        expect(component.users).toEqual(users);
        expect(component.error).toBeNull();
    }));
});
                        </code>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <article class="feature-block">
                <h3>Débogage</h3>
                <div class="debugging-techniques">
                    <div class="technique-item">
                        <h4>Outils de Développement Angular</h4>
                        <ul class="debug-tools">
                            <li>
                                <strong>Angular DevTools</strong>
                                <p>Extension Chrome pour inspecter les composants et l'état</p>
                            </li>
                            <li>
                                <strong>Source Maps</strong>
                                <p>Pour déboguer le code TypeScript directement dans le navigateur</p>
                            </li>
                            <li>
                                <strong>Augury</strong>
                                <p>Visualisation de l'arbre des composants et des dépendances</p>
                            </li>
                        </ul>
                    </div>

                    <div class="technique-item">
                        <h4>Bonnes Pratiques de Débogage</h4>
                        <ul class="debug-practices">
                            <li>Utiliser les points d'arrêt dans le code source</li>
                            <li>Logger les états avec console.log() stratégiquement</li>
                            <li>Implémenter des tests de non-régression</li>
                            <li>Utiliser les outils de profilage pour les performances</li>
                        </ul>
                    </div>
                </div>
            </article>
        </section>

        <section class="course-section">
            <h2>Sécurité dans Angular</h2>
            
            <div class="security-content">
                <article class="feature-item">
                    <h3>Protection XSS</h3>
                    <p>Angular offre une protection intégrée contre les attaques XSS (Cross-Site Scripting) en échappant automatiquement le contenu HTML dangereux. Cependant, il existe des cas où vous devez gérer manuellement la sécurité.</p>
                    <div class="feature-content">
                        <h4>Sanitization</h4>
                        <div class="code-example">
                            <code>
import { DomSanitizer } from '@angular/platform-browser';

export class SecurityComponent {
    constructor(private sanitizer: DomSanitizer) {
        // Sécuriser le contenu HTML dynamique
        this.safeHtml = this.sanitizer.bypassSecurityTrustHtml(htmlContent);
    }
}
                            </code>
                        </div>
                    </div>
                </article>

                <article class="feature-item">
                    <h3>CSRF Protection</h3>
                    <p>La protection contre les attaques CSRF (Cross-Site Request Forgery) est essentielle pour sécuriser vos applications Angular. Angular HttpClient inclut automatiquement des en-têtes XSRF-TOKEN.</p>
                    <div class="feature-content">
                        <ul>
                            <li>Configuration automatique des tokens CSRF</li>
                            <li>Gestion sécurisée des cookies</li>
                            <li>Protection des requêtes HTTP</li>
                        </ul>
                    </div>
                </article>
            </div>
        </section>

        <section class="course-section">
            <h2>Internationalisation (i18n)</h2>
            
            <div class="i18n-content">
                <article class="feature-item">
                    <h3>Configuration de base</h3>
                    <p>L'internationalisation permet d'adapter votre application à différentes langues et régions. Angular fournit des outils puissants pour gérer les traductions.</p>
                    <div class="code-example">
                        <code>
<!-- Template avec i18n -->
&lt;h1 i18n="@@welcomeMessage"&gt;Bienvenue sur notre application&lt;/h1&gt;

<!-- Configuration dans angular.json -->
{
    "i18n": {
        "sourceLocale": "fr",
        "locales": {
            "en": "src/locale/messages.en.xlf",
            "es": "src/locale/messages.es.xlf"
        }
    }
}
                        </code>
                    </div>
                </article>

                <article class="feature-item">
                    <h3>Bonnes Pratiques i18n</h3>
                    <ul>
                        <li>Utiliser des ID uniques pour les messages</li>
                        <li>Gérer les pluriels et expressions</li>
                        <li>Adapter les formats de date et nombres</li>
                        <li>Considérer les directions d'écriture (LTR/RTL)</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="course-section">
            <h2>Patterns de Conception Avancés</h2>
            
            <div class="patterns-content">
                <article class="feature-item">
                    <h3>Container/Presentational Pattern</h3>
                    <p>Ce pattern sépare la logique métier de la présentation, améliorant la réutilisabilité et la testabilité des composants.</p>
                    <div class="code-example">
                        <code>
// Container Component
@Component({
    selector: 'app-user-list-container',
    template: `
        &lt;app-user-list
            [users]="users$ | async"
            (userSelected)="onUserSelect($event)"&gt;
        &lt;/app-user-list&gt;
    `
})
export class UserListContainerComponent {
    users$ = this.userService.getUsers();
    
    onUserSelect(user: User) {
        // Logique métier
    }
}

// Presentational Component
@Component({
    selector: 'app-user-list',
    template: `
        &lt;div *ngFor="let user of users"&gt;
            {{ user.name }}
        &lt;/div&gt;
    `
})
export class UserListComponent {
    @Input() users: User[] = [];
    @Output() userSelected = new EventEmitter<User>();
}
                        </code>
                    </div>
                </article>

                <article class="feature-item">
                    <h3>Smart/Dumb Components</h3>
                    <p>Une approche similaire au Container/Presentational, mais avec une emphase sur la séparation des responsabilités au niveau architectural.</p>
                    <ul>
                        <li><strong>Smart Components:</strong> Gèrent l'état et la logique métier</li>
                        <li><strong>Dumb Components:</strong> Se concentrent uniquement sur l'affichage</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="course-section">
            <h2>Optimisation des Performances</h2>
            
            <div class="performance-content">
                <article class="feature-item">
                    <h3>Techniques d'Optimisation</h3>
                    <div class="optimization-list">
                        <div class="optimization-item">
                            <h4>1. Lazy Loading</h4>
                            <p>Chargez les modules uniquement quand nécessaire pour réduire le bundle initial.</p>
                        </div>
                        <div class="optimization-item">
                            <h4>2. Preloading Strategies</h4>
                            <p>Configurez le préchargement des modules en arrière-plan pour une meilleure expérience utilisateur.</p>
                        </div>
                        <div class="optimization-item">
                            <h4>3. Virtual Scrolling</h4>
                            <p>Gérez efficacement les longues listes en ne rendant que les éléments visibles.</p>
                        </div>
                        <div class="optimization-item">
                            <h4>4. Pure Pipes</h4>
                            <p>Utilisez des pipes purs pour la transformation de données efficace.</p>
                        </div>
                    </div>
                </article>

                <article class="feature-item">
                    <h3>Meilleures Pratiques de Performance</h3>
                    <ul>
                        <li>Utiliser trackBy avec *ngFor</li>
                        <li>Implémenter OnPush ChangeDetection</li>
                        <li>Optimiser les souscriptions RxJS</li>
                        <li>Mettre en cache les résultats des calculs coûteux</li>
                        <li>Utiliser le Server-Side Rendering quand approprié</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="course-section">
            <h2>Gestion de l'État et Communication</h2>
            
            <div class="state-management">
                <article class="state-item">
                    <h3>Services et Injection de Dépendances</h3>
                    <p>Mécanisme puissant pour partager des données et des fonctionnalités entre composants.</p>
                    <div class="code-example">
                        <code>
@Injectable({
    providedIn: 'root'
})
export class DataService {
    private data = new BehaviorSubject<any>({});
    currentData = this.data.asObservable();
}
                        </code>
                    </div>
                </article>

                <article class="state-item">
                    <h3>RxJS et Observables</h3>
                    <ul>
                        <li>Gestion des flux de données asynchrones</li>
                        <li>Opérateurs de transformation</li>
                        <li>Gestion des souscriptions</li>
                        <li>Combinaison de flux de données</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="course-section">
            <h2>Formulaires</h2>
            
            <div class="forms-content">
                <div class="form-type">
                    <h3>Formulaires Template-driven</h3>
                    <p>Basés sur les directives dans le template HTML.</p>
                    <ul>
                        <li>Faciles à mettre en place</li>
                        <li>Validation simple</li>
                        <li>Idéal pour les formulaires simples</li>
                    </ul>
                </div>

                <div class="form-type">
                    <h3>Formulaires Réactifs</h3>
                    <p>Basés sur des modèles de formulaires définis dans le code.</p>
                    <ul>
                        <li>Plus de contrôle</li>
                        <li>Validation complexe</li>
                        <li>Tests unitaires facilités</li>
                        <li>Gestion d'états dynamique</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="course-section">
            <h2>Outils et Écosystème</h2>
            
            <div class="tools-grid">
                <div class="tool-card">
                    <h3><i class="fas fa-terminal"></i> Angular CLI</h3>
                    <p>Outil en ligne de commande pour créer et gérer des projets Angular.</p>
                    <ul>
                        <li>Création de projets</li>
                        <li>Génération de composants</li>
                        <li>Build et déploiement</li>
                    </ul>
                </div>

                <div class="tool-card">
                    <h3><i class="fas fa-paint-brush"></i> Angular Material</h3>
                    <p>Bibliothèque de composants UI suivant les principes du Material Design.</p>
                </div>

                <div class="tool-card">
                    <h3><i class="fas fa-vial"></i> Testing</h3>
                    <p>Outils intégrés pour les tests unitaires et end-to-end.</p>
                    <ul>
                        <li>Jasmine</li>
                        <li>Karma</li>
                        <li>Protractor</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="course-section">
            <h2>Bonnes Pratiques</h2>
            
            <div class="best-practices">
                <ul>
                    <li>Structure de projet claire et modulaire</li>
                    <li>Utilisation appropriée des services</li>
                    <li>Gestion efficace des souscriptions</li>
                    <li>Optimisation des performances</li>
                    <li>Tests unitaires réguliers</li>
                    <li>Documentation du code</li>
                </ul>
            </div>
        </section>

        <section class="course-section">
            <h2>Ressources d'Apprentissage</h2>
            <div class="resources-grid">
                <a href="https://angular.io/docs" target="_blank" class="resource-link">
                    <i class="fas fa-book"></i>
                    Documentation Officielle
                </a>
                <a href="https://angular.io/tutorial" target="_blank" class="resource-link">
                    <i class="fas fa-graduation-cap"></i>
                    Tutorial Tour of Heroes
                </a>
                <a href="https://material.angular.io/" target="_blank" class="resource-link">
                    <i class="fas fa-palette"></i>
                    Angular Material
                </a>
                <a href="https://blog.angular.io/" target="_blank" class="resource-link">
                    <i class="fas fa-rss"></i>
                    Blog Angular
                </a>
            </div>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <p>&copy; <span id="current-year"></span> Formation DWWM - Tous droits réservés</p>
        </div>
    </footer>
    <script src="../scripts.js"></script>
</body>
</html> 